<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stay foolish</title>
    <link>https://wang-kai.github.io/</link>
    <description>Recent content on Stay foolish</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Sun, 03 Aug 2025 06:51:04 +0000</lastBuildDate>
    <atom:link href="https://wang-kai.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>client-go indexer 内部原理及使用</title>
      <link>https://wang-kai.github.io/posts/client-go-indexer/</link>
      <pubDate>Sun, 03 Aug 2025 06:51:04 +0000</pubDate>
      <guid>https://wang-kai.github.io/posts/client-go-indexer/</guid>
      <description>&lt;p&gt;当我们使用 client-go 去 listWatch 一个资源对象时，其中 informer 内部主要执行以下几个步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;reflector 先 List 全量资源，获取到 resourceVersion 后，开始 watch resourceVersion 之后的事件&lt;/li&gt;&#xA;&lt;li&gt;每个 watch 事件（包含事件类型、资源对象）被加入 DeltaFIFO 队列&lt;/li&gt;&#xA;&lt;li&gt;Informer 从 DeltaFIFO 取出 delta 事件开始处理，更新 indexer 内数据&lt;/li&gt;&#xA;&lt;li&gt;Informer 根据事件类型，触发用户定义的处理函数&#xA;Indexer 是 client-go informer 中负责存储数据的模块，是真正最占用内存的模块。本文着重于步骤三，分析 indexer 是如何存储数据以及检索数据的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;https://wang-kai.github.io/k8s-list-watch.png&#34; alt=&#34;&#34;&gt;&#xA;    &lt;figcaption&gt;The working mechanism of an informer&lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9C%AF%E8%AF%AD%E5%AF%B9%E9%BD%90&#34;&gt;术语对齐&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#indexer-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0&#34;&gt;Indexer 内部实现&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#indexer-%E4%BD%BF%E7%94%A8&#34;&gt;Indexer 使用&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8&#34;&gt;基础使用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%B3%A8%E6%84%8F%E7%82%B9&#34;&gt;注意点&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;术语对齐&#34;&gt;术语对齐&lt;/h2&gt;&#xA;&lt;p&gt;Indexer 存储涉及多类 K/V，为了表达清晰，文章开始前先对一些特定名词做清晰定义：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;资源对象 Key：一个资源对象默认的唯一 key (通常是 namespace/name)&lt;/li&gt;&#xA;&lt;li&gt;索引函数：indexer 支持用户自定义索引计算函数 &lt;code&gt;type IndexFunc func(obj interface{}) ([]string, error)&lt;/code&gt;，满足用户按照自己的需求索引资源对象。&lt;/li&gt;&#xA;&lt;li&gt;索引函数名：每一个索引函数都有一个唯一名字&lt;/li&gt;&#xA;&lt;li&gt;索引值：索引函数会针对资源对象计算出一个或多个索引 key，本文内称作索引值&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;indexer-内部实现&#34;&gt;Indexer 内部实现&lt;/h2&gt;&#xA;&lt;p&gt;Indexer 在 Store interface（负责数据的增删改查）基础上增加了索引机制。用户可以自定义索引函数，然后按索引函数计算出的索引值来查询。从 interface 定义可以看出，自定义的 index 相关数据仅支持查询，不支持增删改。因为自定义 index 的相关增删改均是在 Store 相关操作后顺带执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s Patch</title>
      <link>https://wang-kai.github.io/posts/k8s-patch/</link>
      <pubDate>Sun, 13 Apr 2025 11:31:43 +0800</pubDate>
      <guid>https://wang-kai.github.io/posts/k8s-patch/</guid>
      <description>&lt;h2 id=&#34;为什么要有-patch-&#34;&gt;为什么要有 patch ？&lt;/h2&gt;&#xA;&lt;p&gt;K8s 使用乐观锁管理数据，当使用 update 更新资源对象的时候必须带上 &lt;code&gt;resourceVersion&lt;/code&gt; ，这就需要先从 K8s 获取到最新的资源信息，修改字段后再提交给 K8s。如果 apiserver 发现版本比当前存的版本落后就会更新失败。patch 就没有这个问题，可以指定字段立即更新。&lt;/p&gt;&#xA;&lt;h2 id=&#34;patch-操作的-3-种类型&#34;&gt;Patch 操作的 3 种类型&lt;/h2&gt;&#xA;&lt;p&gt;执行 kubectl patch 命令时 &lt;code&gt;--type&lt;/code&gt; 共有三个可选值，&lt;code&gt;strategic&lt;/code&gt; 为默认值，其余还有 &lt;code&gt;json&lt;/code&gt;、&lt;code&gt;merge&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-strategic-merge-patch-不支持自定义资源&#34;&gt;1. Strategic merge patch (不支持自定义资源)&lt;/h3&gt;&#xA;&lt;p&gt;strategic 是默认的 patch 类型，通过命令行操作比较简单：写一个 YAML 指明要更新的字段然后执行即可。例如更新一个 deployment： &lt;code&gt;kubectl patch deploy patch-demo --patch-file patch-file.yaml&lt;/code&gt;。最终行为结果是 replace 还是 merge 取决于被更新字段对 patch 行为的默认定义。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ff79c6&#34;&gt;containers&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: patch-demo-ctr&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;image&lt;/span&gt;: uhub.service.ucloud.cn/library/redis:2.8.8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;比如 &lt;code&gt;pod.spec.containers&lt;/code&gt; 的 patch 策略是 merge , patchMergeKey 为 name。上面这个 patch-file.yaml 提交后会针对 image name 为 patch-demo-ctr 的 container 项做合并。如果 patch-demo-ctr 的 container 不存在，则插入新的 container 到 containers List。  &lt;code&gt;Tolerations&lt;/code&gt; 字段没有 patchStrategy tag ，所以其默认 patch 策略是 replace，直接做替换。&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s controller workqueue 源码学习</title>
      <link>https://wang-kai.github.io/posts/controller-workqueue/</link>
      <pubDate>Sun, 21 Jul 2024 11:31:43 +0800</pubDate>
      <guid>https://wang-kai.github.io/posts/controller-workqueue/</guid>
      <description>&lt;p&gt;在写 K8s controller 的过程中，我们一定会用到 queue，这也是 K8s controller 推荐的范式。本文从源码剖析 K8s client-go 中 workqueue 的底层实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最底层满足特定需求的基础-workqueue&#34;&gt;最底层：满足特定需求的基础 workqueue&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;k8s.io/client-go/util/workqueue&lt;/code&gt; 最基础的 queue 具备以下能力：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;FIFO，元素被处理的顺序与其加入队列的顺序一致&lt;/li&gt;&#xA;&lt;li&gt;严格限制一个元素不会被并行处理。如果一个元素在被处理前多次 enqueue，也会只被处理一次&lt;/li&gt;&#xA;&lt;li&gt;支持多生产者和消费者。即便一个元素正在被处理，也支持将其重新加入队列&lt;/li&gt;&#xA;&lt;li&gt;队列关闭通知。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// Package workqueue provides a simple queue that supports the following&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// features:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//  * Fair: items processed in the order in which they are added.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//  * Stingy: a single item will not be processed multiple times concurrently,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//      and if an item is added multiple times before it can be processed, it&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//      will only be processed once.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//  * Multiple consumers and producers. In particular, it is allowed for an&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//      item to be reenqueued while it is being processed.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;//  * Shutdown notifications.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Interface &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#50fa7b&#34;&gt;Add&lt;/span&gt;(item &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#50fa7b&#34;&gt;Len&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#50fa7b&#34;&gt;Get&lt;/span&gt;() (item &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}, shutdown &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#50fa7b&#34;&gt;Done&lt;/span&gt;(item &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#50fa7b&#34;&gt;ShutDown&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#50fa7b&#34;&gt;ShuttingDown&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;workqueue 具体数据结构比较重要的几个字段如下，支持了 queue 的基础能力&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s informer DeletedFinalStateUnknown 对象的来源与处理</title>
      <link>https://wang-kai.github.io/posts/k8s-controller-deletedfinalstateunknown/</link>
      <pubDate>Sun, 30 Jun 2024 17:45:09 +0800</pubDate>
      <guid>https://wang-kai.github.io/posts/k8s-controller-deletedfinalstateunknown/</guid>
      <description>&lt;p&gt;之前生产环境 volcano 使用遇到一个问题，大致现象是：偶发出现一个 job 被删除了，但相关操作并未执行。最终通过 diff 旧版本与 volcano 最新版本，发现旧版本中未针对 &lt;code&gt;DeletedFinalStateUnknown&lt;/code&gt; 场景做判断和处理，仿照新版本加上这段处理逻辑后问题修复。那么 &lt;code&gt;DeletedFinalStateUnknown&lt;/code&gt; 对象是如何产生的？ controller 应该如何对其处理？作本文以记之。&lt;/p&gt;&#xA;&lt;h2 id=&#34;来源watch-断连丢失数据的补偿机制&#34;&gt;来源：watch 断连丢失数据的补偿机制&lt;/h2&gt;&#xA;&lt;p&gt;在整个 controller 运行中，reflector 组件通过 ListWatch 机制直接与 apiserver 交互，将数据顺序写入 DetlaFIFO。&lt;/p&gt;&#xA;&lt;h4 id=&#34;listwatch-机制简介&#34;&gt;ListWatch 机制简介&lt;/h4&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/client-go/blob/master/tools/cache/reflector.go&#34;&gt;reflector&lt;/a&gt; 源码约 600 行，其中最主要的函数就是 ListAndWatch 和 watchHandler，这两个函数加起来足以阐述 ListWatch 机制。其大致分为两步：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过 List 方法从 apiserver 请求到全量的资源对象，并通过 Replace 方法将对象写入 DeltaFIFO 队列&lt;/li&gt;&#xA;&lt;li&gt;第一步中 List 同时拿到了最新的资源版本，然后调用 Watch 方法异步接收该版本之后的资源对象事件，根据事件类型调用不同方法将对象写入 DeltaFIFO 队列&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;除非遇到特别错误或收到停止信号，watch 过程中断连会重新执行 List 步骤，然后继续建立长连接 watch。但在重新 watch 的过程中就会遇到一个问题：&lt;strong&gt;如果资源对象在中断过程中被删除了，那么如何让 controller 知道对象已被删除呢&lt;/strong&gt;？DeletedFinalStateUnknown 就是该问题的一个补偿方案。&lt;/p&gt;&#xA;&lt;p&gt;Reflector 只负责与 apiserver 通信并将数据存入 DetlaFIFO 内，其中 List 得到的全量最新数据通过 Replace 方法写入，Watch 得到的数据通过 Add/Update/Delete 方法写入。可以说，List 执行结束后拿到的数据是那个时间点最新的数据，如果缓存中有数据不在其中，则表示数据已经被删除。&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8s RBAC 体系中的 User 和 Group</title>
      <link>https://wang-kai.github.io/posts/k8s-rbac-for-user-and-group/</link>
      <pubDate>Sun, 22 Jan 2023 19:44:22 +0800</pubDate>
      <guid>https://wang-kai.github.io/posts/k8s-rbac-for-user-and-group/</guid>
      <description>&lt;p&gt;K8s RBAC 体系中，可以作为授权对象的有 3 个类型：User、Group、ServiceAccount。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ServiceAccout&lt;/code&gt; 作为 K8s 的一种资源类型，有具体的 API 可以操作，本文主要介绍没有具体资源定义，又相对查看困难的 User 、Group 两个对象。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;https://wang-kai.github.io/k8s-rbac-auth.png#center&#34; alt=&#34;&#34;&gt;&#xA;    &lt;figcaption&gt;K8s RBAC model&lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何创建-user-和-group&#34;&gt;如何创建 User 和 Group？&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-签发-x509-client-证书&#34;&gt;1. 签发 X509 Client 证书&lt;/h3&gt;&#xA;&lt;p&gt;通过 CA 签发证书，apiserver auth 逻辑会解析证书的 subject 对象，把其中 &lt;code&gt;common_name（CN）&lt;/code&gt; 作为 User，&lt;code&gt;organization （O）&lt;/code&gt; 作为 Group。例如：kubeconfig 所使用证书的内容（通过 &lt;a href=&#34;https://github.com/cloudflare/cfssl/releases&#34;&gt;cfssl-certinfo&lt;/a&gt; -cert admin.pem 查看）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;subject&amp;#34;&lt;/span&gt;: {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;common_name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;kubernetes-admin&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;organization&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;system:masters&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;names&amp;#34;&lt;/span&gt;: [&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;system:masters&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;kubernetes-admin&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个例子中，User 就是 kubernetes-admin，Group 是 system:masters，其他字段暂可忽略。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-向-kube-apiserver-提供静态文件&#34;&gt;2. 向 kube-apiserver 提供静态文件&lt;/h3&gt;&#xA;&lt;p&gt;kube-apiserver 有一个 &lt;code&gt;--token-auth-file&lt;/code&gt; 参数，通过该参数可以指向一个 csv 格式的文件，在文件内声明 user 和 group。这种方式&lt;strong&gt;所声明的 user 和 group 长期有效，如果要变更文件内容的话，需要重新启动 apiserver&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux free 命令的使用与理解</title>
      <link>https://wang-kai.github.io/posts/linux_free_command/</link>
      <pubDate>Sun, 29 May 2022 12:03:32 +0800</pubDate>
      <guid>https://wang-kai.github.io/posts/linux_free_command/</guid>
      <description>&lt;p&gt;在使用 linux 操作系统时，常见的需求就是查看内存使用情况，比如分析系统健康状况，或者确定机器是否可以部署更多新的业务等等，这是一个常见的需求。&lt;/p&gt;&#xA;&lt;p&gt;解决这个问题也很简单，多数云厂商提供的控制台都会展示各种机器指标的监控信息，内存使用率监控肯定是必不可少的。对 linux 了解一点的，也可以通过 free 命令来查看更详细的信息。当执行 free 命令的时候，不知道是否和我有同样的困惑：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;打印的这么多列具体都代表什么意思？这些列之间的关系是怎样的？&lt;/li&gt;&#xA;&lt;li&gt;内存可用率要看哪个指标？free 还是 available？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;一free-命令的基础使用&#34;&gt;一、free 命令的基础使用&lt;/h2&gt;&#xA;&lt;p&gt;基础使用：free [options]&lt;/p&gt;&#xA;&lt;p&gt;常用参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-h&lt;/code&gt; human-readable 格式打印&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-w&lt;/code&gt; 把 cache &amp;amp; buffer 分开打印&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; show total for RAM + swap&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ free -wth&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              total        used        free      shared     buffers       cache   available&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mem:           125G        6.5G         87G        1.3G        3.5M         30G        116G&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Swap:            0B          0B          0B&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Total:         125G        6.5G         87G&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;二free-命令各列的含义&#34;&gt;二、free 命令各列的含义&lt;/h2&gt;&#xA;&lt;p&gt;free 命令打印的信息来自 &lt;code&gt;/proc/meminfo&lt;/code&gt; （&lt;strong&gt;/proc 不是一个存在于物理磁盘上的目录，而是用于提供内核信息的一个虚拟目录&lt;/strong&gt;），通过解析文件内容来展示物理内存、Swap 内存的使用情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>About Me</title>
      <link>https://wang-kai.github.io/about/</link>
      <pubDate>Wed, 04 May 2022 19:09:32 +0800</pubDate>
      <guid>https://wang-kai.github.io/about/</guid>
      <description>&lt;p&gt;It is wonderful to be here with you. My name is Steve Wang, I live in Shanghai, China. You know, &lt;a href=&#34;https://en.wikipedia.org/wiki/Steve_Jobs&#34;&gt;Steve Jobs&lt;/a&gt; the founder of &lt;a href=&#34;https://www.apple.com/&#34;&gt;Apple Inc&lt;/a&gt; is creative and aspirational, he had great and enduring contributions to the world, my English name comes from him.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;https://wang-kai.github.io/coding_at_night.jpeg#center&#34; alt=&#34;&#34;&gt;&#xA;    &lt;figcaption&gt;Work from home in Shanghai during COVID-19&lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;I am a programmer, which is just a job for making a living sometimes. But I still want to dedicate something to the world, so I created the blog.&lt;/p&gt;</description>
    </item>
    <item>
      <title>go-querystring：把结构体转为 URL query string 的利器</title>
      <link>https://wang-kai.github.io/posts/go_querystring/</link>
      <pubDate>Tue, 03 May 2022 11:31:43 +0800</pubDate>
      <guid>https://wang-kai.github.io/posts/go_querystring/</guid>
      <description>&lt;h2 id=&#34;需求场景&#34;&gt;需求场景&lt;/h2&gt;&#xA;&lt;p&gt;后端服务在调用第三方 API 的时候，常见的需求就是构建 URL query string。在 go 标准包中有 &lt;a href=&#34;https://pkg.go.dev/net/url&#34;&gt;net/url&lt;/a&gt; 来解决这个问题，&lt;code&gt;url.Values&lt;/code&gt; 的本质是一个 &lt;code&gt;map[string][]string&lt;/code&gt;， 且提供一系列方法(Add、Del、Set)来操作参数，最终通过 &lt;code&gt;Encode()&lt;/code&gt; 方法把 map 转为 URL query string。但其中会牵扯到一些重复性工作，比如：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;类型转换，要把 int、bool 等转为 string&lt;/li&gt;&#xA;&lt;li&gt;判断字段是否空或零值的处理逻辑&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;针对这个问题，google 开源的 &lt;a href=&#34;https://github.com/google/go-querystring&#34;&gt;go-querystring&lt;/a&gt;  可以优雅简洁的解决这类重复性工作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用介绍&#34;&gt;使用介绍&lt;/h2&gt;&#xA;&lt;p&gt;整个 go-querystring 库对外仅暴露了一个方法 &lt;code&gt;func Values(v interface{}) (url.Values, error)&lt;/code&gt;，该方法接收一个结构体，返回值是一个填充好数据的 &lt;code&gt;url.Values&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;默认的，URL query string 中 key 值是结构体字段名。如果字段不需要被编码，可以写上 &lt;code&gt;url:&amp;quot;-&amp;quot;&lt;/code&gt; ，对于需要忽略空值的场景，要加上 &lt;code&gt;omitempty&lt;/code&gt;，实例如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; GetPodsReq &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;ClusterID &lt;span style=&#34;color:#8be9fd&#34;&gt;int64&lt;/span&gt;  &lt;span style=&#34;color:#f1fa8c&#34;&gt;`form:&amp;#34;cluster_id&amp;#34; url:&amp;#34;cluster_id,omitempty&amp;#34;`&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Nodenames &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;`form:&amp;#34;nodenames&amp;#34; url:&amp;#34;nodenames,omitempty&amp;#34;`&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Selector  &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;`form:&amp;#34;selector&amp;#34; url:&amp;#34;selector,omitempty&amp;#34;`&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Hostnames &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;`form:&amp;#34;hostnames&amp;#34; url:&amp;#34;hostnames,omitempty&amp;#34;`&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将结构体转为 query string 十分简单，仅需要一个  Values 方法调用即可把结构体转为 &lt;code&gt;url.Values&lt;/code&gt;，然后通过 &lt;code&gt;url.Values&lt;/code&gt; 的  Encode 方法构建出来 query string。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
